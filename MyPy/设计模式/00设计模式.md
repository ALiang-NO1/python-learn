## 工厂模式
### 工厂优点
松耦合，即对象的创建可以独立于类的实现。• 客户端无需了解创建对象的类，但是照样可以使用它来创建对象。它只需要知道需要传递的接口、方法和参数，就能够创建所需类型的对象了。这简化了客户端的实现。• 可以轻松地在工厂中添加其他类来创建其他类型的对象，而这无需更改客户端代码。最简单的情况下，客户端只需要传递另一个参数就可以了。• 工厂还可以重用现有对象。但是，如果客户端直接创建对象的话，总是创建一个新对象。

### Factory模式变体
• 简单工厂模式：允许接口创建对象，但不会暴露对象的创建逻辑。• 工厂方法模式：允许接口创建对象，但使用哪个类来创建对象，则是交由子类决定的。• 抽象工厂模式：抽象工厂是一个能够创建一系列相关的对象而无需指定/公开其具体类的接口。该模式能够提供其他工厂的对象，在其内部创建其他对象。


## 门面（facade）模式
### 结构型设计模式
• 结构型模式描述如何将对象和类组合成更大的结构。• 结构型模式是一种能够简化设计工作的模式，因为它能够找出更简单的方法来认识或表示实体之间的关系。在面向对象世界中，实体指的是对象或类。• 类模式可以通过继承来描述抽象，从而提供更有用的程序接口，而对象模式则描述了如何将对象联系起来从而组合成更大的对象。结构型模式是类和对象模式的综合体。

### 结构型设计模式的例子
• 适配器模式：将一个接口转换成客户希望的另外一个接口。它试图根据客户端的需求来匹配不同类的接口。• 桥接模式：该模式将对象的接口与其实现进行解耦，使得两者可以独立工作。• 装饰器模式：该模式允许在运行时或以动态方式为对象添加职责。我们可以通过接口给对象添加某些属性。除此之外，本书还会介绍其他一些结构型模式。所以，让我们首先从门面设计模式开始学起。

## 理解
门面：建筑表面，内部复杂，封装各种接口，相当于店主
系统：实现子系统功能，又一个类表示
客户端：向门面提出的请求


## 代理模式
### 完成以下工作
它为其他对象提供了一个代理，从而实现了对原始对象的访问控制。• 它可以用作一个层或接口，以支持分布式访问。• 它通过增加代理，保护真正的组件不受意外的影响。

### 结构
• 代理：它是一个控制对RealSubject类访问的类。它处理客户端的请求，负责创建或删除RealSubject。• 主题/真实主题：主题是定义真实主题（RealSubject）和代理（Proxy）相类似的接口。RealSubject是Subject接口的实际实现。它提供了真正的功能，然后由客户端使用。• 客户端：它访问要完成工作的Proxy类。Proxy类在内部控制对RealSubject的访问，并引导客户端（Client）所请求的工作。

### 作用
• 代理可以通过缓存笨重的对象或频繁访问的对象来提高应用程序的性能。• 代理还提供对于真实主题的访问授权。因此，只有提供合适权限的情况下，这个模式才会接受委派。• 远程代理还便于与可用作网络连接和数据库连接的远程服务器进行交互，并可用于监视系统。


## 观察者模式
### 目标
• 它定义了对象之间的一对多的依赖关系，从而使得一个对象中的任何更改都将自动通知给其他依赖对象；• 它封装了主题的核心组件。

### 使用场景
• 在分布式系统中实现事件服务；• 用作新闻机构的框架；• 股票市场也是观察者模式的一个大型场景。

### 结构
• 主题（Subject）：类Subject需要了解Observer。Subject类具有许多方法，诸如register()和deregister()等，Observer可以通过这些方法注册到Subject类中。因此，一个Subject可以处理多个Observer。• 观察者（Observer）：它为关注主题的对象定义了一个接口。它定义了Observer需要实现的各个方法，以便在主题发生变化时能够获得相应的通知。• 具体观察者（ConcreteObserver）：它用来保存应该与Subject的状态保持一致的状态。它实现了Observer接口以保持其状态与主题中的变化相一致。

### 优点
• 它使得彼此交互的对象之间保持松耦合；• 它使得我们可以在无需对主题或观察者进行任何修改的情况下高效地发送数据到其他对象；• 可以随时添加/删除观察者。

### 缺点
• 观察者接口必须由具体观察者实现，而这涉及继承。无法进行组合，因为观察者接口可以实例化；• 如果实现不当的话，观察者可能会增加复杂性，并导致性能降低；• 在软件应用程序中，通知有时可能是不可靠的，并导致竞争条件或不一致性。


# 命令模式
### 优点
• 将调用操作的类与知道如何执行该操作的对象解耦；• 提供队列系统后，可以创建一系列命令；• 添加新命令更加容易，并且无需更改现有代码；• 还可以使用命令模式来定义回滚系统，例如，在向导示例中，我们可以编写一个回滚方法。
### 缺点
• 为了实现目标，需要大量的类和对象进行协作。应用程序开发人员为了正确开发这些类，需要倍加小心；• 每个单独的命令都是一个ConcreteCommand类，从而增加了需要实现和维护的类的数量。


## 模板方法
### 使用场景
• 当多个算法或类实现类似或相同逻辑的时候；• 在子类中实现算法有助于减少重复代码的时候；• 可以让子类利用覆盖实现行为来定义多个算法的时候。

### 意图
• 使用基本操作定义算法的框架；• 重新定义子类的某些操作，而无需修改算法的结构；• 实现代码重用并避免重复工作；• 利用通用接口或实现。

**注：**Swift是一种用于在iOS平台上开发应用程序的编程语言。

### 好莱坞原则
好莱坞原则是一种设计原则，即不要给我们打电话，我们会打给你的。它来自好莱坞哲学，如果有适合演员的角色，影棚会给演员打电话。
在面向对象的世界中，我们允许低层组件使用好莱坞原则将自己挂入系统中。然而，高层组件确定低层系统的使用方式，以及何时需要它们。换句话说，高层组件对待低层组件的方式也是不要给我们打电话，我们会打电话给你。

### 优点
• 没有代码重复；• 由于模板方法模式使用继承而不是合成，因此能够对代码进行重用。所以，只有为数不多的几个方法需要重写；• 灵活性允许子类决定如何实现算法中的步骤。
### 缺点
• 调试和理解模板方法模式中的流程序列有时会令人困惑。你最终实现的方法可能是一个不应该实现的方法，或根本没有实现抽象方法。文档和严格的错误处理必须由程序员完成；• 模板框架的维护可能是一个问题，因为任何层次（低层或高层）的变更都可能对实现造成干扰。因此，使用模板方法模式可能会使维护变得异常痛苦。


## 模型-视图-控制器（MVC）混合模式
### 机制
模型提供数据和业务逻辑（如何存储和查询信息），视图负责数据的展示（如何呈现），而控制器是两者之间的粘合剂，根据用户要求的呈现方式来协调模型和视图。有趣的是，视图和控制器依赖于模型。

### 使用情况
• 当需要更改展示方式而不更改业务逻辑时。• 多个控制器可用于使用多个视图来更改用户界面上的展示。• 再次重申，当模型改变时，视图无需改动，因为它们是相互独立的。
### 意图
• 将数据和数据的展示隔离开来。• 使类的维护和实现更加简单。• 灵活地改变数据的存储和显示方式。两者都是独立的，因此可以灵活修改。


## 状态设计模式
### 优点
• 在状态设计模式中，对象的行为是其状态的函数结果，并且行为在运行时根据状态而改变。这消除了对if/else或switch/case条件逻辑的依赖。例如，在电视远程遥控的场景中，我们还可以通过简单地写一个类和方法来实现相应的行为，但是该类和方法将用到参数，并使用if/else语句块来执行具体操作（打开/关闭电视）。• 使用状态模式，实现多态行为的好处是显而易见的，并且更易于添加状态来支持额外的行为。• 状态设计模式还提高了聚合性，因为特定于状态的行为被聚合到ConcreteState类中，并且放置在代码中的同一个地方。• 使用状态设计模式，通过只添加一个ConcreteState类来添加行为是非常容易的。因此，状态模式不仅改善了扩展应用程序行为时的灵活性，而且全面提高了代码的可维护性。
### 缺点
• 类爆炸：由于每个状态都需要在ConcreteState的帮助下定义，因此我们可能导致创建了太多功能较为单一的类。我们不妨考虑有限状态机的情况——如果有许多状态，但每个状态与另一个状态没有太大不同，我们仍然需要将它们写成单独的ConcreteState类。这既增加了代码量，又使得状态机的结构更加难以审查。• 随着每个新行为的引入（即使添加行为只是添加一个ConcreteState）, Context类都需要进行相应的更新以处理每个行为。这使得上下文行为更容易受到每个新的行为的影响。


## 软件设计反模式
### 不良设计表现
• 不动性：以这种方式开发的应用程序非常难以重用。• 刚性：以这种方式开发的应用程序，任何小的修改都会导致软件的太多部分必须进行相应的改动，所谓“牵一发而动全身”。• 脆弱性：当前应用程序的任何更改都会导致现有系统变得非常容易崩溃。• 粘滞性：由于架构层面的修改非常困难，因此修改必须由开发人员在代码或环境本身中进行。

### 用处
• 识别软件行业中经常出现的问题，并为其中的大多数问题提供详细的补救措施。• 开发相应的工具来识别这些问题，并确定其根本原因。• 描述可用于应用程序和架构层次上的改进措施。

### 意大利面条式代码
• 识别软件行业中经常出现的问题，并为其中的大多数问题提供详细的补救措施。• 开发相应的工具来识别这些问题，并确定其根本原因。• 描述可用于应用程序和架构层次上的改进措施。

### 金锤
在软件行业，你会见到这样的情况：由于某个解决方案（技术、设计或模块）在多个项目中效果不错，所以就把它推广到更多的地方。正如我们在本书中看到的各种例子一样，如果一个解决方案非常适合某种特定场景，那么就可以用来解决这种类型的问题。然而，团队或软件开发人员通常会有这样一种倾向：一头扎进一个成熟的解决方案，而不管其是否满足适用性。这就是“金锤”这个名称的由来，意思是一把锤子搞定所有的钉子（解决所有问题）。
**原因：**
• 来自不了解具体问题的高层（架构师或技术领袖）的建议；• 虽然某解决方案在过去多次验证有效，但当前项目却具有不同的背景和要求；• 公司已经被这种技术“绑架”了，因为他们已经在它上面投资了大量资金来培训员工，或员工们对这种技术情有独钟，因为已经用顺手了。
**影响**
• 痴迷于一个解决方案，并把它应用于所有软件项目；• 不是通过功能，而是通过开发中使用的技术来描述产品；• 你会在公司走廊中听到开发人员说“怎么可能比这个解决方案更好呢”；• 没有满足需求，造成与用户的预期不符。

### 熔岩流
这个反模式与软件应用程序中的死代码或一段用不到的代码有关，并且，人们害怕一旦对其进行修改，就会破坏其他东西。随着时间的流逝，这段代码会一直留在软件中并固化其位置，就像熔岩变成硬岩一样。它常见于这样的情形中：开发的软件是用来支持某个用例的，刚开始并没有什么问题，但如果用例本身会随时间变化的话，那么这个问题就迎面而来了。
**原因：**
• 在产品中有大量的试错代码；• 由一个人单独编写的代码，未经审查，就在没有任何培训的情况下移交给了其他开发团队；• 软件架构或设计的初始思想是通过代码库实现的，但没有人能理解它。
**问题：**
• 开发的测试工作（如果完成的话）具有很低的代码覆盖率；• 代码中含有莫名奇妙的注释；• 过时的接口，或开发人员需要围绕既有代码展开工作；

### 复制粘贴式编程
许多经验丰富的开发人员会将自己的代码片段放到网络上面（GitHub或Stack Overflow），从而为一些常见问题提供相应的解决方案。有些开发人员为了提高开发进度，经常会原封不动地复制这些片段，并用于自己的应用程序中。在这种情况下，根本没有考虑这些代码是否经过了最大程度的优化，甚至连是否真正适合当前的场景都无法确保。这将导致开发的软件应用程序缺乏灵活性，同时变得难以维护。
**原因：**
• 新手开发者不习惯编写代码或不知道如何开发代码；• 快速修复bug或“急就章”式的开发；• 代码重复，无法满足跨模块标准化以及代码结构化的要求；• 缺乏长远打算或深谋远虑。
**后果：**
• 多个软件应用程序存在同种类型的问题；• 维护成本会更高，同时bug的生命周期也会变得更长；• 较少的模块化代码库，相同的代码会散落于多处；• 继承问题。

## 软件架构反模式
### 重新发明轮子
它指的是架构的重用。例如，你已经解决了一个问题，并提出了一个架构级的解决方案。如果你在其他应用程序中遇到了类似的问题，那么就可以重用在此前开发过程中所形成的思维流程（即架构或设计）。重新审视相同的问题并为它重新设计解决方案并没有什么意义，这基本上就是重新发明轮子

**原因：**
• 缺乏中央文档或存储库来讲解架构级问题和存放已实现的解决方案；• 社区或公司内的技术领袖之间缺乏沟通；• 组织中遵循的流程是从头开始构建的，通常情况下，这样的流程是不成熟的，并且流程的实现通常是不严谨的，并且很难坚持。

**后果：**
• 解决一个标准问题的解决方案太多，其中许多解决方案考虑得并不周全；• 会耗费工程团队更多的时间和资源，导致预算超标，上市时间延后；• 封闭的系统架构（仅适用于一种产品的架构）、重复劳动和糟糕的风险管理。

### 重新发明轮子
产品公司往往依赖于供应商提供的某些技术。这些技术对于他们的系统来说如此密不可分，以至于系统很难摆脱这些技术。

**原因：**
• 熟悉供应商公司的权威人士以及技术采购的可能折扣；• 基于营销和销售业务而不是技术评估选择的技术；• 在当前项目中使用经过验证的技术（验证表明，使用此技术的投资回报率非常高），即使它不适合当前项目的需要或要求；• 技术人员/开发人员已经接受过相关技术的培训。

**后果：**
• 公司产品的发布周期和维护周期直接取决于供应商的发布时间；• 该产品是围绕该技术而不是根据客户的要求开发的；• 产品上市时间不可靠，不能满足客户的期望。

### 委员会设计
有时，根据组织中的流程，一群人会坐在一起来设计特定的系统，所得到的软件架构通常是复杂的或不合格的。因为这涉及太多的思维过程，并且这些设计思想可能是由没有相应的技能或相应产品设计经验的技术专家所提出的。

**原因：**
• 根据组织的流程，产品的架构或设计是由众多的利益相关者批准的；• 没有指定单独的联系人或负责设计的架构师；• 由营销或技术专家确定设计优先级，而不是由客户反馈来确定。

**后果：**
• 开发人员和架构师之间的观点冲突，即使在设计完成后依旧如此；• 过于复杂的设计，很难记录；• 规格或设计的任何改动都需要经过多次审查，导致实现延迟。
